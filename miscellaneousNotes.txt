config.yaml: entry point
dataClasses: defines the data classes for config and steam market data
snoozerScheduler: takes the most urgent item, executes it and sleeps till next execution
clockworkScheduler: executes once, then hourly
rateLimiter: maintains the required rate of api calls
utility_files: because we need them in 2025 where the same symbols have variable meaning in different languages.
orchestrator: backend entry point - loads config, creates a shared RateLimiter, starts all schedulers
SQLinserts: routes data to SQLite/TimescaleDB, handles batch inserts

Currency Handling:
- Config: integer codes (1=USD, 3=EUR, 6=RUB, etc.)
- Steam API: accepts integer codes
- Storage: extracts symbols from response â†’ ISO codes (USD, EUR, etc.)
- Fallback: 'USD' if extraction fails (silent default)

Shared RateLimiter:
- Orchestrator creates ONE RateLimiter instance
- Passed to both LiveScheduler and ClockworkScheduler
- Both schedulers share the same rate limit (15 req/60s total, not per scheduler)
- Critical for API compliance when running multiple schedulers

Database:
- SQLite: price_overview, orders_histogram, orders_activity (operational snapshots)
- TimescaleDB: price_history (time-series analysis)
  * Hypertable partitioning, 7-day compression, 90-day retention

SQLite Config (SQLinserts.py line 105-110):
- synchronous=NORMAL: 2-3x faster writes vs FULL, safe enough for market data
- cache_size=-64000: 64MB cache (negative = KB)
- mmap_size=268435456: 256MB memory-mapped I/O
- page_size=4096: optimal for SSDs

TimescaleDB Pool (SQLinserts.py line 34-35):
- min=10, max=100 connections (configurable)
- Supports thousands of concurrent devices
- Why pooling: reuse connections, avoid startup overhead